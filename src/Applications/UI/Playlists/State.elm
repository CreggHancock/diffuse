module UI.Playlists.State exposing (..)

import Alien
import Conditional exposing (ifThenElse)
import Coordinates
import Html.Events.Extra.Mouse as Mouse
import Json.Encode
import List.Extra as List
import Notifications
import Playlists exposing (..)
import Playlists.Encoding as Playlists
import Return exposing (andThen, return)
import Return.Ext as Return
import UI.Common.State as Common
import UI.Page as Page
import UI.Playlists.ContextMenu as Playlists
import UI.Playlists.Page exposing (..)
import UI.Ports as Ports
import UI.Routing.State as Routing
import UI.Tracks as Tracks
import UI.Types as UI exposing (..)



-- üî±


activate : Playlist -> Manager
activate playlist model =
    playlist
        |> Tracks.SelectPlaylist
        |> TracksMsg
        |> Return.performanceF model
        |> andThen redirectToIndexPage


addTracksToPlaylist : { playlistName : String, tracks : List PlaylistTrack } -> Manager
addTracksToPlaylist { playlistName, tracks } model =
    let
        properPlaylistName =
            String.trim playlistName

        playlistIndex =
            List.findIndex
                (\p -> p.autoGenerated == False && p.name == properPlaylistName)
                model.playlists

        newCollection =
            case playlistIndex of
                Just idx ->
                    List.updateAt
                        idx
                        (\p -> { p | tracks = p.tracks ++ tracks })
                        model.playlists

                Nothing ->
                    (::)
                        { autoGenerated = False
                        , name = properPlaylistName
                        , tracks = tracks
                        }
                        model.playlists

        newModel =
            { model
                | playlists = newCollection
                , lastModifiedPlaylist = Just properPlaylistName
            }
    in
    (case tracks of
        [ t ] ->
            "Added __" ++ t.title ++ "__"

        l ->
            "Added __" ++ String.fromInt (List.length l) ++ " tracks__"
    )
        |> (\s -> s ++ " to the __" ++ properPlaylistName ++ "__ playlist")
        |> Notifications.success
        |> Common.showNotificationWithModel newModel
        |> andThen save


create : Manager
create model =
    case model.newPlaylistContext of
        Just playlistName ->
            let
                alreadyExists =
                    List.any
                        (.name >> (==) playlistName)
                        (List.filterNot .autoGenerated model.playlists)

                playlist =
                    { autoGenerated = False
                    , name = playlistName
                    , tracks = []
                    }
            in
            if alreadyExists then
                "There's already a playlist with this name"
                    |> Notifications.error
                    |> Common.showNotificationWithModel model

            else
                { model
                    | lastModifiedPlaylist = Just playlist.name
                    , newPlaylistContext = Nothing
                    , playlists = playlist :: model.playlists
                }
                    |> save
                    |> andThen redirectToIndexPage

        Nothing ->
            Return.singleton model


deactivate : Manager
deactivate model =
    Tracks.DeselectPlaylist
        |> TracksMsg
        |> Return.performanceF model


delete : { playlistName : String } -> Manager
delete { playlistName } model =
    model.playlists
        |> List.filter
            (\p ->
                if p.autoGenerated then
                    True

                else
                    p.name /= playlistName
            )
        |> (\col -> { model | playlists = col })
        |> save


modify : Manager
modify model =
    case model.editPlaylistContext of
        Just { oldName, newName } ->
            let
                properName =
                    String.trim newName

                validName =
                    String.isEmpty properName == False

                ( autoGenerated, notAutoGenerated ) =
                    List.partition .autoGenerated model.playlists

                alreadyExists =
                    List.any
                        (.name >> (==) properName)
                        notAutoGenerated

                newCollection =
                    List.map
                        (\p -> ifThenElse (p.name == oldName) { p | name = properName } p)
                        notAutoGenerated
            in
            if alreadyExists then
                "There's already a playlist with this name"
                    |> Notifications.error
                    |> Common.showNotificationWithModel
                        { model | editPlaylistContext = Nothing }

            else if validName then
                { model
                    | editPlaylistContext = Nothing
                    , lastModifiedPlaylist = Just properName
                    , playlists = newCollection ++ autoGenerated
                }
                    |> save
                    |> andThen redirectToIndexPage

            else
                redirectToIndexPage model

        Nothing ->
            redirectToIndexPage model


save : Manager
save model =
    model.playlists
        |> List.filterNot .autoGenerated
        |> Json.Encode.list Playlists.encode
        |> Alien.broadcast Alien.SavePlaylists
        |> Ports.toBrain
        |> return model


setCreationContext : String -> Manager
setCreationContext playlistName model =
    Return.singleton { model | newPlaylistContext = Just playlistName }


setModificationContext : String -> String -> Manager
setModificationContext oldName newName model =
    let
        context =
            { oldName = oldName
            , newName = newName
            }
    in
    Return.singleton { model | editPlaylistContext = Just context }


showListMenu : Playlist -> Mouse.Event -> Manager
showListMenu playlist mouseEvent model =
    let
        coordinates =
            Coordinates.fromTuple mouseEvent.clientPos

        contextMenu =
            Playlists.listMenu
                playlist
                model.tracks.collection.identified
                model.confirmation
                coordinates
    in
    Return.singleton { model | contextMenu = Just contextMenu }



-- „äôÔ∏è


redirectToIndexPage : Manager
redirectToIndexPage =
    Routing.changeUrlUsingPage (Page.Playlists Index)
